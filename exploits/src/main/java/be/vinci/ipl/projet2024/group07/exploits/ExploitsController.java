package be.vinci.ipl.projet2024.group07.exploits;

import be.vinci.ipl.projet2024.group07.exploits.models.Exploit;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/exploits")
public class ExploitsController {

  private final ExploitsService exploitsService;

  public ExploitsController(ExploitsService exploitsService) {
    this.exploitsService = exploitsService;
  }

  @GetMapping
  public ResponseEntity<List<Exploit>> getAllExploits(@RequestParam(required = false) String serverType) {
    List<Exploit> exploits = exploitsService.listExploits(serverType);
    return new ResponseEntity<>(exploits, HttpStatus.OK);
  }

  @GetMapping("/author/{authorId}")
  public ResponseEntity<List<Exploit>> getExploitsByAuthor(@PathVariable int authorId) {
    List<Exploit> exploits = exploitsService.getExploitsByAuthor(authorId);
    if (exploits.isEmpty()) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }
    return new ResponseEntity<>(exploits, HttpStatus.OK);
  }

  @PostMapping
  public ResponseEntity<Exploit> createExploit(@RequestBody Exploit exploit) {
    if (exploit.getName() == null || exploit.getName().isBlank()) {
      return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }
    if (exploit.getAuthorId() <= 0) {
      return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }

    Exploit createdExploit = exploitsService.createExploit(exploit);
    return new ResponseEntity<>(createdExploit, HttpStatus.CREATED);
  }

  @GetMapping("/{exploitId}")
  public ResponseEntity<Exploit> getExploitById(@PathVariable int exploitId) {
    return exploitsService.getExploitById(exploitId)
        .map(exploit -> new ResponseEntity<>(exploit, HttpStatus.OK))
        .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
  }

  @PutMapping("/{exploitId}")
  public ResponseEntity<Void> updateExploit(@PathVariable int exploitId, @RequestBody Exploit exploit) {
    exploit.setId(exploitId);
    try {
      exploitsService.updateExploit(exploit);
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } catch (IllegalArgumentException e) {
      return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }
  }

  @DeleteMapping("/{exploitId}")
  public ResponseEntity<Void> deleteExploit(@PathVariable int exploitId) {
    try {
      exploitsService.deleteExploit(exploitId);
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } catch (IllegalArgumentException e) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }
  }

  @DeleteMapping("/author/{authorId}")
  public ResponseEntity<Void> deleteExploitsByAuthor(@PathVariable int authorId) {
    try {
      exploitsService.deleteExploitsByAuthor(authorId);
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } catch (IllegalArgumentException e) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }
  }

  @PatchMapping("/{exploitId}/validate")
  public ResponseEntity<Void> validateExploit(@PathVariable int exploitId) {
    try {
      exploitsService.validateExploit(exploitId);
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } catch (IllegalArgumentException e) {
      return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }
  }
}
