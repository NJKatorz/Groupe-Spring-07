package be.vinci.ipl.projet2024.group07.exploits;

import be.vinci.ipl.projet2024.group07.exploits.models.Exploit;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/exploits")
public class ExploitsController {

  private final ExploitsService exploitsService;

  public ExploitsController(ExploitsService exploitsService) {
    this.exploitsService = exploitsService;
  }

  /**
   * Récupère tous les exploits.
   * @param serverType le type de serveur (optionnel).
   * @return une réponse HTTP contenant la liste des exploits et le statut HTTP OK.
   */
  @GetMapping
  public ResponseEntity<List<Exploit>> getAllExploits(@RequestParam(required = false) String serverType) {
    List<Exploit> exploits = exploitsService.listExploits(serverType);
    return new ResponseEntity<>(exploits, HttpStatus.OK);
  }

  /**
   * Récupère les exploits par auteur.
   * @param authorId l'ID de l'auteur.
   * @return une réponse HTTP contenant la liste des exploits de l'auteur et le statut HTTP OK,
   * ou le statut HTTP NOT_FOUND si aucun exploit n'est trouvé.
   */
  @GetMapping("/author/{authorId}")
  public ResponseEntity<List<Exploit>> getExploitsByAuthor(@PathVariable int authorId) {
    List<Exploit> exploits = exploitsService.getExploitsByAuthor(authorId);
    if (exploits.isEmpty()) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }
    return new ResponseEntity<>(exploits, HttpStatus.OK);
  }

  /**
   * Crée un nouvel exploit.
   * @param exploit l'exploit à créer.
   * @return une réponse HTTP contenant l'exploit créé et le statut HTTP CREATED,
   * ou le statut HTTP BAD_REQUEST si les données de l'exploit sont invalides.
   */
  @PostMapping
  public ResponseEntity<Exploit> createExploit(@RequestBody Exploit exploit) {
    if (exploit.getName() == null || exploit.getName().isBlank() || exploit.getServerType() == null
        || exploit.getServerType().isBlank() || exploit.getGuide() == null || exploit.getGuide().isBlank()
        ||exploit.getDescription() == null || exploit.getDescription().isBlank() ) {
      return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }
    if (exploit.getAuthorId() <= 0) {
      return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }

    Exploit createdExploit = exploitsService.createExploit(exploit);
    return new ResponseEntity<>(createdExploit, HttpStatus.CREATED);
  }

  /**
   * Récupère un exploit en fonction de son ID.
   * @param exploitId l'ID de l'exploit à récupérer.
   * @return une réponse HTTP contenant l'exploit correspondant et le statut HTTP OK,
   * ou le statut HTTP NOT_FOUND si aucun exploit n'est trouvé.
   */
  @GetMapping("/{exploitId}")
  public ResponseEntity<Exploit> getExploitById(@PathVariable int exploitId) {
    return exploitsService.getExploitById(exploitId)
        .map(exploit -> new ResponseEntity<>(exploit, HttpStatus.OK))
        .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
  }

  /**
   * Met à jour un exploit existant.
   * @param exploitId l'ID de l'exploit à mettre à jour.
   * @param exploit l'exploit mis à jour.
   * @return une réponse HTTP avec le statut NO_CONTENT si la mise à jour est réussie,
   * ou une réponse HTTP avec le statut BAD_REQUEST si les données de l'exploit sont invalides.
   */
  @PutMapping("/{exploitId}")
  public ResponseEntity<Void> updateExploit(@PathVariable int exploitId, @RequestBody Exploit exploit) {
    exploit.setId(exploitId);
    try {
      exploitsService.updateExploit(exploit);
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } catch (IllegalArgumentException e) {
      return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }
  }

  /**
   * Supprime un exploit par son ID.
   * @param exploitId l'ID de l'exploit à supprimer.
   * @return une réponse HTTP avec le statut NO_CONTENT si la suppression est réussie,
   * ou le statut HTTP NOT_FOUND si l'exploit n'est pas trouvé.
   */
  @DeleteMapping("/{exploitId}")
  public ResponseEntity<Void> deleteExploit(@PathVariable int exploitId) {
    try {
      exploitsService.deleteExploit(exploitId);
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } catch (IllegalArgumentException e) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }
  }

  /**
   * Supprime les exploits d'un auteur.
   * @param authorId l'ID de l'auteur.
   * @return une réponse HTTP avec le statut NO_CONTENT si la suppression est réussie,
   * ou le statut HTTP NOT_FOUND si l'auteur n'est pas trouvé.
   */
  @DeleteMapping("/author/{authorId}")
  public ResponseEntity<Void> deleteExploitsByAuthor(@PathVariable int authorId) {
    try {
      exploitsService.deleteExploitsByAuthor(authorId);
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } catch (IllegalArgumentException e) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }
  }

  /**
   * Valide un exploit existant.
   * @param exploitId l'ID de l'exploit à valider.
   * @return une réponse HTTP avec le statut NO_CONTENT si la validation est réussie,
   * ou une réponse HTTP avec le statut BAD_REQUEST si l'exploit n'est pas trouvé.
   */
  @PatchMapping("/{exploitId}/validate")
  public ResponseEntity<Void> validateExploit(@PathVariable int exploitId) {
    try {
      exploitsService.validateExploit(exploitId);
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } catch (IllegalArgumentException e) {
      return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }
  }
}
