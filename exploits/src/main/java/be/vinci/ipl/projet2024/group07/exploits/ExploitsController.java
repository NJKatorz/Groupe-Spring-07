package be.vinci.ipl.projet2024.group07.exploits;

import be.vinci.ipl.projet2024.group07.exploits.models.Exploit;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/exploits")
public class ExploitsController {

  private final ExploitsService exploitsService;

  public ExploitsController(ExploitsService exploitsService) {
    this.exploitsService = exploitsService;
  }

  @GetMapping
  public ResponseEntity<List<Exploit>> getAllExploits(
      @RequestParam(required = false) String serverType) {
    List<Exploit> exploits = (serverType != null) ?
        exploitsService.getExploitsByServerType(serverType) :
        exploitsService.getAllExploits();

    return new ResponseEntity<>(exploits, HttpStatus.OK);
  }

  @PostMapping
  public ResponseEntity<Exploit> createExploit(@RequestBody Exploit exploit) {
    Exploit createdExploit = exploitsService.createExploit(exploit);

    if (createdExploit == null) {
      return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }
    return new ResponseEntity<>(createdExploit, HttpStatus.CREATED);
  }

  @GetMapping("/{exploitId}")
  public ResponseEntity<Exploit> getExploitById(@PathVariable int exploitId) {
    Exploit exploit = exploitsService.getExploitById(exploitId);

    if (exploit == null) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }
    return new ResponseEntity<>(exploit, HttpStatus.OK);
  }


  @PutMapping("/{exploitId}")
  public ResponseEntity<Void> updateExploit(@PathVariable int exploitId, @RequestBody Exploit exploit) {
    boolean isUpdated = exploitsService.updateExploit(exploitId, exploit);

    if (isUpdated) {
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } else {
      return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }
  }

  @DeleteMapping("/{exploitId}")
  public ResponseEntity<Void> deleteExploit(@PathVariable int exploitId) {
    boolean isDeleted = exploitsService.deleteExploit(exploitId);

    if (isDeleted) {
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } else {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }
  }

  @PatchMapping("/{exploitId}/validate")
  public ResponseEntity<Void> validateExploit(@PathVariable int exploitId) {
    boolean isValidated = exploitsService.validateExploit(exploitId);

    if (isValidated) {
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } else {
      return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    }
  }

  @GetMapping("/author/{authorId}")
  public ResponseEntity<List<Exploit>> getExploitsByAuthor(@PathVariable int authorId) {
    List<Exploit> exploits = exploitsService.getExploitsByAuthorId(authorId);

    if (exploits.isEmpty()) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }
    return new ResponseEntity<>(exploits, HttpStatus.OK);
  }

  @DeleteMapping("/author/{authorId}")
  public ResponseEntity<Void> deleteExploitsByAuthor(@PathVariable int authorId) {
    boolean isDeleted = exploitsService.deleteExploitsByAuthor(authorId);

    if (isDeleted) {
      return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    } else {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }
  }
}
