package be.vinci.ipl.projet2024.group07.exploits;

import be.vinci.ipl.projet2024.group07.exploits.models.Exploit;
import be.vinci.ipl.projet2024.group07.exploits.repositories.AttacksProxy;
import be.vinci.ipl.projet2024.group07.exploits.repositories.ExploitsRepository;
import be.vinci.ipl.projet2024.group07.exploits.repositories.UsersProxy;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class ExploitsService {

  private final ExploitsRepository exploitsRepository;
  private final UsersProxy usersProxy;
  private final AttacksProxy attacksProxy;

  public ExploitsService(ExploitsRepository exploitsRepository, UsersProxy usersProxy, AttacksProxy attacksProxy) {
    this.exploitsRepository = exploitsRepository;
    this.usersProxy = usersProxy;
    this.attacksProxy = attacksProxy;
  }

  /**
   * Liste tous les exploits, avec possibilité de filtrer par type de serveur.
   *
   * @param serverType le type de serveur (optionnel)
   * @return liste des exploits
   */
  public List<Exploit> listExploits(String serverType) {
    if (serverType != null) {
      return exploitsRepository.findByServerType(serverType);
    }
    return (List<Exploit>) exploitsRepository.findAll();
  }

  public Exploit createExploit(Exploit exploit) {
    if (!userExists(exploit.getAuthorId())) {
      throw new IllegalArgumentException("L'utilisateur n'existe pas");
    }

    exploit.setValidated(false);
    return exploitsRepository.save(exploit);
  }

  public Optional<Exploit> getExploitById(int exploitId) {
    return exploitsRepository.findById(exploitId);
  }

  public Exploit updateExploit(Exploit exploit) {
    if (!exploitsRepository.existsById(exploit.getId())) {
      throw new IllegalArgumentException("L'exploit n'existe pas");
    }
    return exploitsRepository.save(exploit);
  }

  public void deleteExploit(int exploitId) {
    if (!exploitsRepository.existsById(exploitId)) {
      throw new IllegalArgumentException("L'exploit n'existe pas");
    }


    attacksProxy.deleteAttacksByExploit(exploitId);


    exploitsRepository.deleteById(exploitId);
  }


  public void validateExploit(int exploitId) {
    Optional<Exploit> exploitOpt = exploitsRepository.findById(exploitId);
    if (exploitOpt.isEmpty()) {
      throw new IllegalArgumentException("L'exploit n'existe pas");
    }

    Exploit exploit = exploitOpt.get();
    if (exploit.isValidated()) {
      throw new IllegalArgumentException("L'exploit est déjà validé");
    }

    // Mettre l'exploit en état validé
    exploit.setValidated(true);
    exploitsRepository.save(exploit);
  }

  /**
   * Liste les exploits d'un auteur spécifique.
   *
   * @param authorId l'ID de l'auteur
   * @return liste des exploits
   */
  public List<Exploit> listExploitsByAuthor(int authorId) {
    return exploitsRepository.findByAuthorId(authorId);
  }

  public void deleteExploitsByAuthor(int authorId) {
    List<Exploit> exploits = exploitsRepository.findByAuthorId(authorId);
    if (exploits.isEmpty()) {
      throw new IllegalArgumentException("Aucun exploit trouvé pour cet auteur");
    }


    for (Exploit exploit : exploits) {
      attacksProxy.deleteAttacksByExploit(exploit.getId());
    }


    exploitsRepository.deleteAll(exploits);
  }


  private boolean userExists(int userId) {
    try {
      usersProxy.getUserById(userId);
      return true;
    } catch (Exception e) {
      return false;
    }
  }
}
