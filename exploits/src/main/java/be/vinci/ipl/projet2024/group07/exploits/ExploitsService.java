package be.vinci.ipl.projet2024.group07.exploits;

import be.vinci.ipl.projet2024.group07.exploits.models.Exploit;
import be.vinci.ipl.projet2024.group07.exploits.repositories.AttacksProxy;
import be.vinci.ipl.projet2024.group07.exploits.repositories.ExploitsRepository;
import be.vinci.ipl.projet2024.group07.exploits.repositories.UsersProxy;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class ExploitsService {

  private final ExploitsRepository exploitsRepository;
  private final UsersProxy usersProxy;
  private final AttacksProxy attacksProxy;

  public ExploitsService(ExploitsRepository exploitsRepository, UsersProxy usersProxy, AttacksProxy attacksProxy) {
    this.exploitsRepository = exploitsRepository;
    this.usersProxy = usersProxy;
    this.attacksProxy = attacksProxy;
  }

  /**
   * Récupère tous les exploits.
   * @param serverType le type de serveur (optionnel).
   * @return une liste d'exploits correspondant au type de serveur spécifié, ou tous les exploits si aucun type n'est spécifié.
   */
  public List<Exploit> listExploits(String serverType) {
    if (serverType != null) {
      return exploitsRepository.findByServerType(serverType);
    }
    return exploitsRepository.findAll();
  }

  /**
   * Crée un nouvel exploit.
   * @param exploit l'exploit à créer.
   * @return l'exploit créé.
   * @throws IllegalArgumentException si l'utilisateur n'existe pas ou si les données de l'exploit sont invalides.
   */
  public Exploit createExploit(Exploit exploit) {
    validateExploit(exploit);
    if (!userExists(exploit.getAuthorId())) {
      throw new IllegalArgumentException("L'utilisateur n'existe pas");
    }
    exploit.setValidated(false);
    return exploitsRepository.save(exploit);
  }

  /**
   * Récupère un exploit par son ID.
   * @param exploitId l'ID de l'exploit.
   * @return un Optional contenant l'exploit s'il est trouvé, ou un Optional vide sinon.
   */
  public Optional<Exploit> getExploitById(int exploitId) {
    return exploitsRepository.findById(exploitId);
  }

  /**
   * Récupère les exploits par auteur.
   * @param authorId l'ID de l'auteur.
   * @return une liste d'exploits de l'auteur spécifié.
   */
  public List<Exploit> getExploitsByAuthor(int authorId) {
    return exploitsRepository.findByAuthorId(authorId);
  }

  /**
   * Met à jour un exploit existant.
   * @param exploit l'exploit mis à jour.
   * @throws IllegalArgumentException si l'exploit n'existe pas ou si les données de l'exploit sont invalides.
   */
  public void updateExploit(Exploit exploit) {
    validateExploit(exploit);
    if (!exploitsRepository.existsById(exploit.getId())) {
      throw new IllegalArgumentException("L'exploit n'existe pas");
    }
    exploitsRepository.save(exploit);
  }

  /**
   * Supprime un exploit en fonction de son ID.
   * @param exploitId l'ID de l'exploit à supprimer.
   * @throws IllegalArgumentException si l'exploit n'existe pas.
   */
  public void deleteExploit(int exploitId) {
    if (!exploitsRepository.existsById(exploitId)) {
      throw new IllegalArgumentException("L'exploit n'existe pas");
    }
    attacksProxy.deleteAttacksByExploit(exploitId);
    exploitsRepository.deleteById(exploitId);
  }

  /**
   * Valide un exploit existant.
   * @param exploitId l'ID de l'exploit à valider.
   * @throws IllegalArgumentException si l'exploit n'existe pas ou s'il est déjà validé.
   */
  public void validateExploit(int exploitId) {
    Optional<Exploit> exploitOpt = exploitsRepository.findById(exploitId);
    if (exploitOpt.isEmpty()) {
      throw new IllegalArgumentException("L'exploit n'existe pas");
    }
    Exploit exploit = exploitOpt.get();
    if (exploit.isValidated()) {
      throw new IllegalArgumentException("L'exploit est déjà validé");
    }
    exploit.setValidated(true);
    exploitsRepository.save(exploit);
  }

  /**
   * Vérifie si un utilisateur existe.
   * @param userId l'ID de l'utilisateur.
   * @return true si l'utilisateur existe, false sinon.
   */
  private boolean userExists(int userId) {
    try {
      usersProxy.getUserById(userId);
      return true;
    } catch (Exception e) {
      return false;
    }
  }

  /**
   * Valide les données d'un exploit.
   * @param exploit l'exploit à valider.
   * @throws IllegalArgumentException si les données de l'exploit sont invalides.
   */
  private void validateExploit(Exploit exploit) {
    if (exploit.getName() == null || exploit.getName().isBlank()) {
      throw new IllegalArgumentException("Le nom de l'exploit est requis.");
    }
    if (exploit.getAuthorId() <= 0) {
      throw new IllegalArgumentException("L'auteur est invalide.");
    }
    if (exploit.getServerType() == null || exploit.getServerType().isBlank()) {
      throw new IllegalArgumentException("Le type de serveur est requis.");
    }
  }

  /**
   * Supprime les exploits d'un auteur.
   * @param authorId l'ID de l'auteur.
   * @throws IllegalArgumentException si aucun exploit n'est trouvé pour cet auteur.
   */
  public void deleteExploitsByAuthor(int authorId) {

    List<Exploit> exploits = exploitsRepository.findByAuthorId(authorId);

    if (exploits.isEmpty()) {
      throw new IllegalArgumentException("Aucun exploit trouvé pour cet auteur");
    }

    exploits.forEach(exploit -> attacksProxy.deleteAttacksByExploit(exploit.getId()));

    exploitsRepository.deleteByAuthorId(authorId);
  }
}
