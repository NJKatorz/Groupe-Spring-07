package be.vinci.ipl.projet2024.group07.exploits;

import be.vinci.ipl.projet2024.group07.exploits.models.Exploit;
import be.vinci.ipl.projet2024.group07.exploits.repositories.AttacksProxy;
import be.vinci.ipl.projet2024.group07.exploits.repositories.ExploitsRepository;
import be.vinci.ipl.projet2024.group07.exploits.repositories.UsersProxy;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class ExploitsService {

  private final ExploitsRepository exploitsRepository;
  private final UsersProxy usersProxy;
  private final AttacksProxy attacksProxy;

  public ExploitsService(ExploitsRepository exploitsRepository, UsersProxy usersProxy, AttacksProxy attacksProxy) {
    this.exploitsRepository = exploitsRepository;
    this.usersProxy = usersProxy;
    this.attacksProxy = attacksProxy;
  }

  public List<Exploit> listExploits(String serverType) {
    if (serverType != null) {
      return exploitsRepository.findByServerType(serverType);
    }
    return exploitsRepository.findAll();
  }

  public Exploit createExploit(Exploit exploit) {
    validateExploit(exploit);
    if (!userExists(exploit.getAuthorId())) {
      throw new IllegalArgumentException("L'utilisateur n'existe pas");
    }
    exploit.setValidated(false);
    return exploitsRepository.save(exploit);
  }

  public Optional<Exploit> getExploitById(int exploitId) {
    return exploitsRepository.findById(exploitId);
  }

  public void updateExploit(Exploit exploit) {
    validateExploit(exploit);
    if (!exploitsRepository.existsById(exploit.getId())) {
      throw new IllegalArgumentException("L'exploit n'existe pas");
    }
    exploitsRepository.save(exploit);
  }

  public void deleteExploit(int exploitId) {
    if (!exploitsRepository.existsById(exploitId)) {
      throw new IllegalArgumentException("L'exploit n'existe pas");
    }
    attacksProxy.deleteAttacksByExploit(exploitId);
    exploitsRepository.deleteById(exploitId);
  }

  public void validateExploit(int exploitId) {
    Optional<Exploit> exploitOpt = exploitsRepository.findById(exploitId);
    if (exploitOpt.isEmpty()) {
      throw new IllegalArgumentException("L'exploit n'existe pas");
    }
    Exploit exploit = exploitOpt.get();
    if (exploit.isValidated()) {
      throw new IllegalArgumentException("L'exploit est déjà validé");
    }
    exploit.setValidated(true);
    exploitsRepository.save(exploit);
  }

  private boolean userExists(int userId) {
    try {
      usersProxy.getUserById(userId);
      return true;
    } catch (Exception e) {
      return false;
    }
  }

  private void validateExploit(Exploit exploit) {
    if (exploit.getName() == null || exploit.getName().isBlank()) {
      throw new IllegalArgumentException("Le nom de l'exploit est requis.");
    }
    if (exploit.getAuthorId() <= 0) {
      throw new IllegalArgumentException("L'auteur est invalide.");
    }
    if (exploit.getServerType() == null || exploit.getServerType().isBlank()) {
      throw new IllegalArgumentException("Le type de serveur est requis.");
    }
  }
}
